/*
 * Work under Copyright. Licensed under the EUPL.
 * See the project README.md and LICENSE.txt for more information.
 */

package net.dries007.tfc.world.biome;

import java.util.ArrayList;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.function.LongFunction;
import javax.annotation.Nullable;

import net.minecraft.util.RegistryKey;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.registry.DynamicRegistries;
import net.minecraft.util.registry.Registry;
import net.minecraft.world.IBiomeReader;
import net.minecraft.world.IWorld;
import net.minecraft.world.biome.Biome;
import net.minecraft.world.biome.BiomeMaker;
import net.minecraftforge.common.BiomeDictionary;
import net.minecraftforge.fml.server.ServerLifecycleHooks;
import net.minecraftforge.registries.DeferredRegister;
import net.minecraftforge.registries.ForgeRegistries;

import com.mojang.datafixers.util.Pair;
import net.dries007.tfc.util.collections.FiniteLinkedHashMap;
import net.dries007.tfc.world.noise.INoise2D;

import static net.dries007.tfc.TerraFirmaCraft.MOD_ID;

public final class TFCBiomes
{
    public static final DeferredRegister<Biome> BIOMES = DeferredRegister.create(ForgeRegistries.BIOMES, MOD_ID);

    private static final List<RegistryKey<Biome>> DEFAULT_BIOME_KEYS = new ArrayList<>(); // All possible biomes generated by the TFC BiomeProvider
    private static final List<BiomeVariants> VARIANTS = new ArrayList<>();
    private static final Map<RegistryKey<Biome>, BiomeExtension> EXTENSIONS = new IdentityHashMap<>(); // All extensions, indexed by registry key for quick access

    // Aquatic biomes
    public static final BiomeVariants OCEAN = register("ocean", seed -> BiomeNoise.ocean(seed, -20, -12), BiomeVariants.LargeGroup.OCEAN, true, BiomeDictionary.Type.OCEAN); // Ocean biome found near continents.
    public static final BiomeVariants DEEP_OCEAN = register("deep_ocean", seed -> BiomeNoise.ocean(seed, -38, -18), BiomeVariants.LargeGroup.OCEAN, true, BiomeDictionary.Type.OCEAN); // Deep ocean biome covering most all oceans.
    public static final BiomeVariants DEEP_OCEAN_RIDGE = register("deep_ocean_ridge", seed -> BiomeNoise.oceanRidge(seed, -38, -18), BiomeVariants.LargeGroup.OCEAN, true, BiomeDictionary.Type.OCEAN);

    // Low biomes
    public static final BiomeVariants PLAINS = register("plains", seed -> BiomeNoise.simple(seed, 4, 10), BiomeDictionary.Type.PLAINS); // Very flat, slightly above sea level.
    public static final BiomeVariants HILLS = register("hills", seed -> BiomeNoise.simple(seed, -5, 16), BiomeDictionary.Type.HILLS); // Small hills, slightly above sea level.
    public static final BiomeVariants LOWLANDS = register("lowlands", BiomeNoise::lowlands, BiomeDictionary.Type.SWAMP); // Flat, swamp-like, lots of shallow pools below sea level.
    public static final BiomeVariants LOW_CANYONS = register("low_canyons", seed -> BiomeNoise.canyons(seed, -5, 15), BiomeDictionary.Type.HILLS, BiomeDictionary.Type.SWAMP); // Sharp, small hills, with lots of water / snaking winding rivers.

    // Mid biomes
    public static final BiomeVariants ROLLING_HILLS = register("rolling_hills", seed -> BiomeNoise.simple(seed, -5, 28), BiomeDictionary.Type.HILLS); // Higher hills, above sea level. Some larger / steeper hills.
    public static final BiomeVariants BADLANDS = register("badlands", BiomeNoise::badlands, BiomeDictionary.Type.HILLS, BiomeDictionary.Type.MESA); // Very high flat area with steep relief carving, similar to vanilla mesas.
    public static final BiomeVariants PLATEAU = register("plateau", seed -> BiomeNoise.simple(seed, 20, 30), BiomeDictionary.Type.PLATEAU); // Very high area, very flat top.
    public static final BiomeVariants CANYONS = register("canyons", seed -> BiomeNoise.canyons(seed, -7, 26), BiomeDictionary.Type.SWAMP, BiomeDictionary.Type.HILLS); // Medium height with snake like ridges, often slightly below sea level

    // High biomes
    public static final BiomeVariants MOUNTAINS = register("mountains", seed -> BiomeNoise.mountains(seed, 10, 70), BiomeDictionary.Type.MOUNTAIN); // High, picturesque mountains. Pointed peaks, low valleys well above sea level.
    public static final BiomeVariants FLOODED_MOUNTAINS = register("flooded_mountains", seed -> BiomeNoise.mountains(seed, -16, 60), true, BiomeDictionary.Type.OCEAN, BiomeDictionary.Type.MOUNTAIN); // Mountains with high areas, and low, below sea level valleys. Water is salt water here.
    public static final BiomeVariants OLD_MOUNTAINS = register("old_mountains", seed -> BiomeNoise.mountains(seed, 16, 40), BiomeDictionary.Type.PLATEAU, BiomeDictionary.Type.MOUNTAIN); // Rounded top mountains, very large hills.

    // Shores
    public static final BiomeVariants SHORE = register("shore", BiomeNoise::shore, BiomeVariants.LargeGroup.OCEAN, true, BiomeDictionary.Type.BEACH); // Standard shore / beach. Material will vary based on location

    // Water
    public static final BiomeVariants LAKE = register("lake", BiomeNoise::lake, BiomeVariants.LargeGroup.LAKE, false, BiomeDictionary.Type.RIVER);
    public static final BiomeVariants RIVER = register("river", BiomeNoise::river, BiomeVariants.LargeGroup.RIVER, BiomeVariants.SmallGroup.RIVER, false, BiomeDictionary.Type.RIVER);

    // Water "Carver" Biomes
    public static final CarvingBiomeVariants MOUNTAIN_RIVER = registerCarving("mountain_river", MOUNTAINS, BiomeNoise::riverCarving, BiomeDictionary.Type.MOUNTAIN, BiomeDictionary.Type.RIVER);
    public static final CarvingBiomeVariants OLD_MOUNTAIN_RIVER = registerCarving("old_mountain_river", OLD_MOUNTAINS, BiomeNoise::riverCarving, BiomeDictionary.Type.PLATEAU, BiomeDictionary.Type.MOUNTAIN, BiomeDictionary.Type.RIVER);
    public static final CarvingBiomeVariants FLOODED_MOUNTAIN_RIVER = registerCarving("flooded_mountain_river", FLOODED_MOUNTAINS, BiomeNoise::riverCarving, BiomeDictionary.Type.MOUNTAIN, BiomeDictionary.Type.OCEAN, BiomeDictionary.Type.RIVER);
    public static final CarvingBiomeVariants MOUNTAIN_LAKE = registerCarving("mountain_lake", MOUNTAINS, BiomeNoise::lakeCarving, BiomeDictionary.Type.MOUNTAIN, BiomeDictionary.Type.RIVER);
    public static final CarvingBiomeVariants OLD_MOUNTAIN_LAKE = registerCarving("old_mountain_lake", OLD_MOUNTAINS, BiomeNoise::lakeCarving, BiomeDictionary.Type.PLATEAU, BiomeDictionary.Type.MOUNTAIN, BiomeDictionary.Type.RIVER);
    public static final CarvingBiomeVariants FLOODED_MOUNTAIN_LAKE = registerCarving("flooded_mountain_lake", FLOODED_MOUNTAINS, BiomeNoise::lakeCarving, BiomeDictionary.Type.MOUNTAIN, BiomeDictionary.Type.OCEAN, BiomeDictionary.Type.RIVER);
    public static final CarvingBiomeVariants PLATEAU_LAKE = registerCarving("plateau_lake", PLATEAU, BiomeNoise::lakeCarving, BiomeDictionary.Type.PLATEAU, BiomeDictionary.Type.RIVER);
    private static final Map<Biome, BiomeExtension> CACHED_EXTENSIONS = new FiniteLinkedHashMap<>(16); // Faster route from biome -> extension

    public static BiomeExtension getExtensionOrThrow(IWorld world, Biome biome)
    {
        BiomeExtension extension = getExtension(world, biome);
        if (extension == null)
        {
            throw new IllegalStateException("Biome missing a required extension!");
        }
        return extension;
    }

    @Nullable
    public static BiomeExtension getExtension(Biome biome)
    {
        return getExtension(ServerLifecycleHooks.getCurrentServer().registryAccess(), biome);
    }

    @Nullable
    public static BiomeExtension getExtension(IBiomeReader world, Biome biome)
    {
        return getExtension(world.registryAccess(), biome);
    }

    @Nullable
    public static BiomeExtension getExtension(DynamicRegistries registries, Biome biome)
    {
        // First query the cache, it is fast
        BiomeExtension extension = CACHED_EXTENSIONS.get(biome);
        if (extension == BiomeExtension.EMPTY)
        {
            // No match for this biome - this exists as a cache miss marker
            return null;
        }
        else if (extension != null)
        {
            // Cache hit
            return extension;
        }
        else
        {
            // This lookup here is the comparatively slow operation - avoid it if possible as this is happening a lot.
            Registry<Biome> registry = registries.registryOrThrow(Registry.BIOME_REGISTRY);
            BiomeExtension lookupExtension = registry.getResourceKey(biome).map(EXTENSIONS::get).orElse(null);
            if (lookupExtension != null)
            {
                // Save the extension and biome to the cache
                CACHED_EXTENSIONS.put(biome, lookupExtension);
                return lookupExtension;
            }
            else
            {
                // Mark this as a cache miss with the empty extension
                CACHED_EXTENSIONS.put(biome, BiomeExtension.EMPTY);
                return null;
            }
        }
    }

    public static List<RegistryKey<Biome>> getAllKeys()
    {
        return DEFAULT_BIOME_KEYS;
    }

    public static List<BiomeVariants> getVariants()
    {
        return VARIANTS;
    }

    public static void registerDefaultBiomeDictionaryTypes(RegistryKey<Biome> key, BiomeTemperature temp, BiomeRainfall rain)
    {
        BiomeDictionary.addTypes(key, BiomeDictionary.Type.OVERWORLD);
        if (temp == BiomeTemperature.FROZEN)
        {
            BiomeDictionary.addTypes(key, BiomeDictionary.Type.SNOWY, BiomeDictionary.Type.COLD);
        }
        else if (temp == BiomeTemperature.COLD)
        {
            BiomeDictionary.addTypes(key, BiomeDictionary.Type.COLD);
        }
        else if (temp == BiomeTemperature.WARM || temp == BiomeTemperature.LUKEWARM)
        {
            BiomeDictionary.addTypes(key, BiomeDictionary.Type.HOT);
        }

        if (rain == BiomeRainfall.WET || rain == BiomeRainfall.DAMP)
        {
            BiomeDictionary.addTypes(key, BiomeDictionary.Type.WET);
        }
        else if (rain == BiomeRainfall.DRY)
        {
            BiomeDictionary.addTypes(key, BiomeDictionary.Type.DRY);
        }
        else if (rain == BiomeRainfall.ARID)
        {
            BiomeDictionary.addTypes(key, BiomeDictionary.Type.DRY, BiomeDictionary.Type.SANDY);
        }

        if (rain == BiomeRainfall.WET && temp == BiomeTemperature.WARM)
        {
            BiomeDictionary.addTypes(key, BiomeDictionary.Type.JUNGLE);
        }
        else if (rain == BiomeRainfall.ARID && temp == BiomeTemperature.WARM)
        {
            BiomeDictionary.addTypes(key, BiomeDictionary.Type.SAVANNA);
        }
        else if (temp == BiomeTemperature.COLD && rain != BiomeRainfall.ARID)
        {
            BiomeDictionary.addTypes(key, BiomeDictionary.Type.CONIFEROUS);
        }
    }

    private static CarvingBiomeVariants registerCarving(String baseName, BiomeVariants parent, LongFunction<Pair<INoise2D, INoise2D>> carvingNoiseFactory, BiomeDictionary.Type... types)
    {
        return createBiomes(new CarvingBiomeVariants(parent, carvingNoiseFactory), baseName, types);
    }

    private static BiomeVariants register(String baseName, LongFunction<INoise2D> noiseFactory, BiomeDictionary.Type... types)
    {
        return register(baseName, noiseFactory, BiomeVariants.LargeGroup.LAND, BiomeVariants.SmallGroup.BODY, false, types);
    }

    private static BiomeVariants register(String baseName, LongFunction<INoise2D> noiseFactory, boolean salty, BiomeDictionary.Type... types)
    {
        return register(baseName, noiseFactory, BiomeVariants.LargeGroup.LAND, BiomeVariants.SmallGroup.BODY, salty, types);
    }

    private static BiomeVariants register(String baseName, LongFunction<INoise2D> noiseFactory, BiomeVariants.LargeGroup largeGroup, boolean salty, BiomeDictionary.Type... types)
    {
        return register(baseName, noiseFactory, largeGroup, BiomeVariants.SmallGroup.BODY, salty, types);
    }

    /**
     * Registers all variants corresponding to a biome super type
     */
    private static BiomeVariants register(String baseName, LongFunction<INoise2D> noiseFactory, BiomeVariants.LargeGroup largeGroup, BiomeVariants.SmallGroup smallGroup, boolean salty, BiomeDictionary.Type... types)
    {
        return createBiomes(new BiomeVariants(noiseFactory, smallGroup, largeGroup, salty), baseName, types);
    }

    private static <V extends BiomeVariants> V createBiomes(V variants, String baseName, BiomeDictionary.Type... types)
    {
        VARIANTS.add(variants);
        for (BiomeTemperature temp : BiomeTemperature.values())
        {
            for (BiomeRainfall rain : BiomeRainfall.values())
            {
                String name = baseName + "_" + temp.name().toLowerCase() + "_" + rain.name().toLowerCase();
                ResourceLocation id = new ResourceLocation(MOD_ID, name);
                RegistryKey<Biome> key = RegistryKey.create(Registry.BIOME_REGISTRY, id);
                BiomeExtension extension = new BiomeExtension(key, variants);

                EXTENSIONS.put(key, extension);
                DEFAULT_BIOME_KEYS.add(key);
                TFCBiomes.BIOMES.register(name, BiomeMaker::theVoidBiome);

                registerDefaultBiomeDictionaryTypes(key, temp, rain);
                BiomeDictionary.addTypes(key, types);

                variants.put(temp, rain, extension);
            }
        }
        return variants;
    }
}